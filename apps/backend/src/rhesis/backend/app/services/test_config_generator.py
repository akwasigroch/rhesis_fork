"""
Test Configuration Generator Service.

This service handles the generation of test configurations based on user prompts
using LLM and Jinja2 templates.
"""

from pathlib import Path
from typing import List

import jinja2
from sqlalchemy.orm import Session

from rhesis.backend.app import crud
from rhesis.backend.app.schemas.services import (
    TestConfigItem,
    TestConfigLLMResponse,
    TestConfigResponse,
)
from rhesis.sdk.models.providers.gemini import GeminiLLM


class TestConfigGeneratorService:
    """Service for generating test configurations from user prompts."""

    def __init__(self, max_sample_size: int = 20):
        """Initialize the service with template environment.

        Args:
            max_sample_size: Maximum allowed sample size per category (default: 20)
        """
        self.template_dir = Path(__file__).parent.parent / "templates"
        self.jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(str(self.template_dir)),
            autoescape=jinja2.select_autoescape(),
            trim_blocks=True,
            lstrip_blocks=True,
        )
        self.llm = GeminiLLM()
        self.max_sample_size = max_sample_size

    def generate_config(
        self, prompt: str, sample_size: int = 5, db: Session = None, organization_id: str = None
    ) -> TestConfigResponse:
        """
        Generate test configuration based on user prompt.

        Behaviors are fetched from the database based on organization_id,
        while topics and categories are generated by the LLM.

        Args:
            prompt: User description of what they want to test
            sample_size: Number of items to generate for each category (default: 5, max: 20)
            db: Database session for fetching behaviors
            organization_id: Organization ID for filtering behaviors

        Returns:
            TestConfigResponse: Generated test configuration with behaviors from DB

        Raises:
            ValueError: If prompt is empty or invalid, or if db/organization_id not provided
            RuntimeError: If LLM response cannot be parsed
        """
        if not prompt or not prompt.strip():
            raise ValueError("Prompt cannot be empty")

        if sample_size < 1:
            raise ValueError("Sample size must be at least 1")
        if sample_size > self.max_sample_size:
            raise ValueError(f"Sample size must be less than {self.max_sample_size}")

        if db is None or organization_id is None:
            raise ValueError("Database session and organization_id are required")

        # Fetch behaviors from database (limited to max 100 by validation)
        behaviors = crud.get_behaviors(
            db=db,
            organization_id=organization_id,
            skip=0,
            limit=100,  # Maximum allowed by validation
        )

        # Convert behaviors to TestConfigItem format
        behavior_items: List[TestConfigItem] = [
            TestConfigItem(name=behavior.name, description=behavior.description or "")
            for behavior in behaviors
        ]

        # Render template with user prompt and sample size
        template = self.jinja_env.get_template("test_config_generator.jinja2")
        rendered_prompt = template.render({"prompt": prompt, "sample_size": sample_size})

        # Generate topics and categories using LLM
        llm_response = self.llm.generate(rendered_prompt, schema=TestConfigLLMResponse)

        # Handle response whether it's a dict or TestConfigLLMResponse object
        if isinstance(llm_response, dict):
            llm_response = TestConfigLLMResponse(**llm_response)

        # Combine database behaviors with LLM-generated topics and categories
        return TestConfigResponse(
            behaviors=behavior_items, topics=llm_response.topics, categories=llm_response.categories
        )
